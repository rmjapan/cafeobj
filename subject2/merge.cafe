mod! MERGESORT {
  pr(NATLIST)
  [PairOfLists]
  op pair : NatList NatList -> PairOfLists {constr} .
  op left : PairOfLists -> NatList .
  op right : PairOfLists -> NatList .
  eq left(pair(L1, L2)) = L1 .
  eq right(pair(L1, L2)) = L2 .
  op mergesort : NatList -> NatList .
  op merge : NatList NatList -> NatList .
  op split : NatList -> PairOfLists .
  vars L1 L2 : NatList .
  vars X Y : Nat .
  vars L : NatList .
  eq merge(nil, L2) = L2 .
  eq merge(L1, nil) = L1 .
  eq merge(X | L1, Y | L2) =
    if X < Y then { X | merge(L1, Y | L2) }
    else { Y | merge(X | L1, L2) } .
  eq mergesort(nil) = nil .
  eq mergesort(X | nil) = X | nil .
  eq mergesort(L) =
    merge(mergesort(left(split(L))), mergesort(right(split(L)))) .
  eq split(nil) = pair(nil, nil) .
  eq split(X | nil) = pair(X | nil, nil) .
  eq split(X | Y | L) = pair(X | left(split(L)), Y | right(split(L))) .
}
open MERGESORT .
red mergesort(nil) .
red mergesort(4 | nil) .
red mergesort(5 | 4 | nil) .
red mergesort(9 | 3 | nil) .
red mergesort(1 | 2 | 3 | 4 | 5 | nil) .
red mergesort(4 | 4 | 4 | 4 | nil) .
red mergesort(9 | 1 | 6 | 3 | 8 | nil) .
red mergesort(100 | 1 | 50 | 0 | 99 | 2 | nil) .

close